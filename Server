import socketserver, sys
import os
from collections import defaultdict
from pprint import pprint
import json
import ast

my_unix_command = ['bc']
HOST = '0.0.0.0'
PORT = 2000

activeAlarms = {}
pastAlarms = defaultdict(lambda: {1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: []})
authorizations = defaultdict(lambda: [])
invites = (defaultdict(lambda: []))
users = []

with open('activeAlarms.txt', 'r') as f:
    s = f.read()
    if len(s) > 0:
        activeAlarms = ast.literal_eval(s)

#After this should check if any of the active alarms have already timed out

with open('pastAlarms.txt', 'r') as f:
    s = f.read()
    if len(s) > 0:
        pastAlarms = ast.literal_eval(s)

with open('authorizations.txt', 'r') as f:
    s = f.read()
    if len(s) > 0:
        authorizations = ast.literal_eval(s)

with open('users.txt', 'r+') as f:
    s = f.read()
    if len(s) > 0:
        users = ast.literal_eval(s)

print(activeAlarms)
print(users)
print(pastAlarms)
print(authorizations)


class SingleTCPHandler(socketserver.BaseRequestHandler):
    "One instance per connection.  Override handle(self) to customize action."
    def handle(self):
        # self.request is the client connection
        data = self.request.recv(1024)  # clip input at 1Kb
        text = data.decode('utf-8')
        pprint(json.loads(text))
        jsonRequest = json.loads(text)

        if jsonRequest['msgType'] == 'newUser':

            if jsonRequest['user'] not in users:
                users.append(jsonRequest['user'])
                with open('users.txt', 'w') as file:
                    file.write(json.dumps(users))

        if jsonRequest['msgType'] == 'newAlarm':

            #TODO: Use time library from python
            entry = {
                'weekday': jsonRequest['weekday'],
                'hour': jsonRequest['hours'],
                'minute': jsonRequest['minutes'],
                #'settings': jsonRequest['settings']
            }

            #Override the current active alarm for the user as only one is can be active
            activeAlarms[jsonRequest['user']] = entry

            with open('activeAlarms.txt', 'w') as file:
                file.write(json.dumps(activeAlarms))

            #TODO: start a timer here to latter triger the respective arduino

            #Here should communicate with the arduino
            #s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM);
            #s1.bind(arduinos[jsonRequest['user']])

            #s1.send("hello form server")

        if jsonRequest['msgType'] == 'getAlarms':

            user = jsonRequest['user']
            others_flag = jsonRequest['controlledUsers']

            #Here I will either send mine or all my controlled

            if others_flag:
                alarms = defaultdict(lambda: {})
                for u in authorizations[user]:
                    alarms[u] = activeAlarms[u]
                self.request.send(json.dumps(alarms).encode('utf-8'))

            if not others_flag:
                if user in activeAlarms:
                    self.request.send(json.dumps(activeAlarms[user]).encode('utf-8'))

        if jsonRequest['msgType'] == 'getStatistics':

            user = jsonRequest['user']
            statistics = {1: {}, 2: {}, 3: {}, 4: {}, 5: {}, 6: {}, 7: {}}

            for a in pastAlarms[user]:
                if len(pastAlarms[user][a]) > 0:
                    avg = sum(pastAlarms[user][a])/len(pastAlarms[user][a])
                    statistics[a] = avg

            self.request.send(json.dumps(statistics).encode('utf-8'))

        if jsonRequest['msgType'] == 'getUsers':

            control_flag = jsonRequest['all']

            if control_flag:
                self.request.send(json.dumps(authorizations[user]))

            if not control_flag:
                other_users = []
                for u in users:
                    if u not in authorizations[user]:
                        other_users.append(u)
                self.request.send(json.dumps(other_users).encode('utf-8'))

        if jsonRequest['msgType'] == 'invite':

            user = jsonRequest['user']
            invite_user = jsonRequest['invited']

            invites[invite_user].append(user)
            self.request.send('OK'.encode('utf-8'))


        # if jsonRequest['msgType'] == 'helloArduino':
        #     pprint("Arduino said hello from: "+jsonRequest['user'])
        #     pprint("Addr: "+str(self.client_address))
        #     pprint("Port: "+"...")
        #     arduinos[jsonRequest['user']] = self.client_address
        #     self.request.sendall(json.dumps(activeAlarms[jsonRequest['user']]).encode('utf-8'))

        #self.request.send('OK'.encode('utf-8'))
        self.request.close()


class SimpleServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    # Ctrl-C will cleanly kill all spawned threads
    daemon_threads = True
    # much faster rebinding
    allow_reuse_address = True

    def __init__(self, server_address, RequestHandlerClass):
        socketserver.TCPServer.__init__(self, server_address, RequestHandlerClass)


if __name__ == "__main__":
    server = SimpleServer((HOST, PORT), SingleTCPHandler)
    # terminate with Ctrl-C
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        sys.exit(0)
